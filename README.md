# Лабораторная работа № 6. Безусловный экстремум.

Выполнил студент группы 428  
Гурьянов Максим Олегович

## Вариант № 11
Найти точку **минимума**

![FUNC](Images/FUNC.png)

![NachPribliz](Images/NachPribliz.png)

методом **сопряженных градиентов**. Для одномерной минимизации использовать метод **квадратичной интерполяции**.
Для поиска интервала унимодальности использовать алгоритм **скользящего окна**.
В окрестности точки минимума построить линии уровня и траекторию поиска (на одном графике). За своевременное
выполнение задания начисляется **6 баллов**.
Реализовав дополнительно следующие методы можно получить по **3 балла** за каждый метод: метод случайного 
поиска, метод Нелдера-Мида, метод Пауэлла, метод Хука-Дживса, метод Розенброка.

## Теоретическая часть

### Метод сопряжённых градиентов
*Алгоритм:*<br>

Начальный этап.<br>

Задаём начальное приближение ![x0](Images/x0.png) и задаём точность ![](Images/eqn.png), с которой будем искать решение.<br>
Находим формулы компонент градиента функции в произвольной точке: ![](Images/VectGrad.png).<br>
  ![](Images/k.png)(счетчик итераций)<br>

Основной этап.<br>
1. Вычислим ![](Images/gradF.png)<br>
2. Проверим выполнение критерия останова ![](Images/modGrad.png)<br>

а) Если критерий выполнен, расчет окончен, ![](Images/xResh.png)<br>
б) Если критерий не выполнен и  ![](Images/k.png), то переходим к шагу 3.<br>
в) Если критерий не выполнен и  ![](Images/knon.png), то переходим к шагу 4.<br>

3. Определим ![](Images/p0.png) и нормируем этот вектор<br><br>
4. Определим ![](Images/beta3.png) в случае квадратичной ф-ции, а в случае неквадратичной - <br>
<br>![](Images/beta2.png)<br><br> 
5. Определим ![](Images/pK.png) и нормируем вектор ![](Images/pkk.png)<br> <br>
6. Вычислим величину шага ![](Formuls/alfa.png) из условия ![](Images/UslMin.png) сведением задачи к поиску минимума
ф-ции одной переменной (одномерный поиск)<br>
7. Вычислим ![](Images/Xk1.png)<br>
8. Положим ![](Images/Kplus.png) и перейдём к шагу 1.<br>
### Метод квадратичной интерполяции
*Алгоритм:*<br>
1. Находим интервал унимодальности ![](Images/interval.png) методом скользящего окна<br>
2. Задаем произвольный шаг ![](Images/hUsl.png)<br>
3. Задаем 3 пробные точки: ![](Formuls/x1.png), ![](Images/x2Zamen.png) и, если  ![](Images/Uslinter.png), то  ![](Images/x3Zam1.png), иначе ![](Images/x3Zam2.png) <br><br>
4. Вычисляем значения ф-ции в точках : ![](Images/Znachen.png)<br><br>
5. Находим ![](Images/argmin.png) (аргумент, при котором получается наименьшее значение функции)<br><br>
6. Строим квадратичный интерполяционный многочлен по 3-м точкам и вычисляем его точку минимума по формуле:<br>
![](Images/x_.png)<br><br> Если знаменатель в формуле равен нулю, выбираем ![](Images/x1min.png), <br> ![](Images/x2Zamen.png), и, если  ![](Formuls/Uslinter.png), то  ![](Formuls/x3Zam1.png), иначе ![](Formuls/x3Zam2.png).<br> И повторяем нахождение ![](Images/xzvezda.png) и ![](Images/argmin.png) <br><br>
7. Проверяем выполнение условий останова поиска: ![](Images/eps1.png) и ![](Images/eps2.png)<br>
а) Если условия выполняются, то поиск заканчивается, ![](Images/xzvezda.png) - минимум ф-ции одной переменной<br><br>
б) Если условия не выполняются и ![](Images/prinadlez.png), то точка ![](Images/x11.png) заменяется на точку![](Images/argmin2.png),
![](Images/x2Zamen.png) и, если  ![](Images/Uslinter.png), то  ![](Images/x3Zam1.png), иначе ![](Images/x3Zam2.png)<br><br>
в) Иначе, точка ![](Images/x11.png) заменяется на точку![](Images/xzvezda.png), ![](Images/x2Zamen.png) и, если  ![](Images/Uslinter.png), то  ![](Images/x3Zam1.png), иначе ![](Images/x3Zam2.png)<br><br>
8. Вернуться к шагу 4. <br>
### Эвристический алгоритм скользящего окна нахождения интервала унимодальности близжайшего к заданной точке *x*
*Алгоритм:*<br>
1. Выбираем исходную точку ![](Images/x0.png) и какой-то шаг ![](Images/hUsl.png) <br>
2. Около точки ![](Images/x0.png) проверяем условие унимодальности: ![](Images/UslUnimod.png)<br><br>
а) Если условие выполняется, то интервал унимодальности найден и ![](Images/a.png), ![](Images/b.png)<br><br>
б) Если условие не выполняется, то проверяем условие: ![](Formuls/UslUnimod1.png).<br> Если оно выполняется, тогда ![](Images/x0.png) заменяется на  ![](Images/xx.png) (окно сдвигается вправо), иначе ![](Images/x0.png) заменяется на![](Images/xx1.png) (окно сдвигается влево) <br><br>
3. Возвращаемся к шагу 2.<br><br>
## Практическая часть
Моя работа состоит из 2-х программ: <br>
1) Программа с реализацией поиска экстремума ф-ции, написанная на языке C++<br>
2) Программа для отрисовки линий уровня ф-ции и траектории поиска экстремума, написанная на Python<br><br>

Программа на C++ состоит из 1-го файла **`Labb6.cpp`**<br><br>

Структура программы:<br>
* В начале программы продключаются библиотеки: <br>
     `iostream` - стандартная библиотека ввода/вывода<br>
     `cmath` - стандартная библиотека для выполнения математических операций <br>
     `fstream` - библиотека для чтения/записи данных из/в файл <br>
* `double F(double x1, double x2)` - функция 2-х переменных, которая дана в билете<br>
* `double grad1(double x1, double x2)` - 1-ая компонента вектора градиента исходной ф-ции<br>
* `double grad2(double x1, double x2)` - 2-ая компоненту вектора градиента исходной ф-ции<br>
* В классе `Sopr` описаны переменные и методы, необходмые для отыскания точки экстремума:
  * *private* - методы и переменные класса:<br>
    * `h` - произвольный шаг, используемый в методе квадратичной интерполяции и методе нахождения интервала унимодальности
    * `k` - счетчик итераций в методе сопряженных градиентов
    * двумерные статические массивы `x0` и  `x1` для записи предыдущего и последующего приближения точки экстремума функции
    * двумерные статические массивы `p0` и  `p1` для записи предыдущего и последующего значений вектора направления                            ![FUNC](Images/vectP.png) в методе сопряж-х град-в
    * `fout` - объект класса ofstream для записи в файл новых значений вектора  ![](Images/xK.png) 
    * ` double f(double alfa)` - та же функция `double F(double x1, double x2)`, только для случая, когда переменные x1 и x2 в свою очередь зависят от  ![](Images/alfa.png). Она необходима для поиска экстремума ф-ции одной переменной в методе квадратичной интерп-ции
    * `double interpMnogochlen(double& x1, double& x2, double& x3)` - квадратичный интерполяционный многочлен, используемый в методе квадр-й интерполяции
    * 'double argmin(double x1, double x2, double x3)' - возвращает один из 3-х аргументов, при котором исходная ф-ция имеет наименьшее значение
    * 'double argmin(double x1, double x2)' - возвращающает один из 2-х аргументов, при котором исходная ф-ция имеет наименьшее значение
    
  * *public* - методы и переменные класса:
    * `int GetIter()` - возвращающает кол-во итераций, за которое удалось найти минимум нашей функции
    * `double* soprGrad()` - реализует *метод сопряженных градиентов*. Возвращает адрес найденной точки минимума.
    * `double KvadrInterp(double a, double b)` - реализует *метод квадратичной интерполяции*. Возвращает минимум ф-ции одной переменной.
    * `void unimodal(double x0, double& a, double& b)` - находит интервал унимодальности нашей ф-ции
   
* В методе `int main()` создается объект типа `Sopr`, у которого вызывается ф-я `soprGrad()`. В консоль выводится найденная точка минимума и кол-во итераций.  
Также ф-я `soprGrad()` создает в папке с программой файл `tr.txt`, в который записываются значения вектора ![](Formuls/xK.png) для построения траектории поиска.<br>
И в конце с помощью команды `system("linur.py")` вызывается питоновский файл, в котором построенна траектория поиска.<br><br>

Программа на Python состоит из 1-го файла **`linur.py`**<br>

В ней строится картина линий уровня нашей ф-ции с помощью метода `contour()` из библиотеки `pylab` и траектория поиска по данным из файла `tr.txt`.<br>

**Порядок компилляции/запуска:**<br>
1. Компиллируем и запускаем файл **`Labb6.cpp`** из командной строки при помощи команды:<br>
`g++ Labb6.cpp -o Labb6.o`<br><br>
2. Запускаем из командной строки `Labb6.o`<br><br>

### Результаты
В результате работы программы у функции <br><br> ![](Images/FUNC.png) <br><br>был найден экстремум в точке  ![](Images/minimum.png) (начальная точка  ![](Images/nachTochk.png)) за ***8*** итераций методами: <br>
1) Квадратичной интерполяции с точностью  ![](Images/e1.png) <br>
2) Сопряженных градиентов с точностью  ![](Images/e3.png) <br>

 ![](Images/linur.jpg) 